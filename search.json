[
  {
    "objectID": "blog.html",
    "href": "blog.html",
    "title": "Drawing Blog",
    "section": "",
    "text": "- Useful for compliance and security reviews (ISO, NIST, SOC2).\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "posts/PSDV Assignment Blog.html",
    "href": "posts/PSDV Assignment Blog.html",
    "title": "Exposition Assignment PSDV",
    "section": "",
    "text": "STOP DRAWING START CODING : Automating Architecture Diagrams with mingrammer/diagrams\nEver spent hours perfecting an architecture diagram, only to have one tiny system update throw everything off? Sounds frustrating, right? What if you could generate professional, scalable, and dynamic system diagrams, just by writing a few lines of Python code?\nWelcome to mingrammer/diagrams—a powerful Python library that lets you create cloud, DevOps, and infrastructure diagrams effortlessly!\n\nNo more dragging and tweaking of shapes.\nNo more struggling with alignment.\nNo more outdated documentation.\n\nWith Diagrams, you can now turn your code into accurate, stunning and professional system diagrams within seconds. In this blog, we’ll explore the following areas:\n\nIntroduction to Diagrams\nInstallation setup\nCore features\nAdvanced features\nReal-world use cases\nMore references\nConclusion\n\nPrerequisites\nPython: This versatile programming language will serve as our trusty companion throughout the process. Ensure to install python version 3.7 or above.\nIntroduction\nIn early 2020, python library Diagrams was created by a Korean developer MinJae Kwon. This Python-based library allows developers to generate professional system diagrams with just few lines of code. With Diagrams, you can create AWS, GCP, Kubernetes, On-Prem, and SaaS infrastructure diagrams programmatically, making it an excellent tool for DevOps engineers, cloud architects, and system designers.\nWhat is Diagrams?\nDiagrams is an open-source Python library that allows you to generate architecture diagrams programmatically. Instead of dragging and dropping elements in a diagramming tool, you can write simple Python code to create cloud architecture, microservices, and DevOps pipeline diagrams.\nWhat is “Diagrams as Code”?\nThe concept of “Diagrams as Code” refers to automating the process of diagram generation using code instead of manually designing visuals. Just like Infrastructure as Code (IaC) automates cloud provisioning, Diagrams as Code makes system documentation easier, scalable, and version-controlled.\n\n\n\n\n\n\n\n\nAspect\nManual Approach\nDiagrams as Code Approach\n\n\n\n\nCreation Method\nManually design diagrams using Visio, Lucidchart, Draw.io\nWrite Python scripts to generate diagrams programmatically\n\n\nMaintenance\nDifficult to update and maintain when system changes\nEasily editable and reusable—update with code changes\n\n\nAccuracy\nProne to human errors and inconsistencies\nEnsures precision and consistency\n\n\nCollaboration\nHard to track changes in team projects\nVersion-controlled with GitHub/GitLab\n\n\nAutomation\nNo automation—manual updates required\nReal-time updates with automated documentation\n\n\n\nNow let’s see how to install and setup Diagrams in Python\nBefore installing Diagrams you need to install:\n\nPython 3.7+ (https://www.python.org/downloads/)\nGraphviz\n\nGraphviz (Graph Visualization Software) is an open-source tool used for generating diagrams and graphs from text-based descriptions. It is widely used for network diagrams, architecture visualization, dependency graphs, and flowcharts.\nWhy is Graphviz Important?\n Required by Diagrams (mingrammer/diagrams) for rendering visuals.\n Automatic layout generation (arranges nodes and edges efficiently).\n Supports multiple formats (PNG, SVG, PDF, etc).\n Integrates with Python, C, Java, etc.\nTo Install Graphviz:\n\nFor Window Users:\n\n\nDownload and install Graphviz.\nAdd Graphviz to the system PATH variable. o Open System Properties . o Go to the Advanced tab then Click on the Environment Variables. o Under System Variables, find Path, click Edit. o Add the Graphviz bin directory path, which is usually: C: Files Then Click OK and restart your terminal.\nCheck that the Graphviz is installed by running the following code:\n\n\npip install Graphviz\n\nRequirement already satisfied: Graphviz in c:\\users\\priya\\appdata\\local\\programs\\python\\python310\\lib\\site-packages (0.20.3)\nNote: you may need to restart the kernel to use updated packages.\n\n\n\ndot -V\n\nIf Graphviz is installed correctly, you must see the output as follows:\n\ndot - Graphviz version 2.49.3 (2025-02-22)\n\n\nFor macOS Users:\n\nTo install Graphviz by using homebrew run the code:\n\nbrew install Graphviz\n\nTo check that the Graphviz is installed, run the code:\n\ndot –V\n\nIf the output is as follows, then you have istalled Graphviz successfully!\n\ndot - Graphviz version 2.49.3\n\n\nFor Linux Users:\n\nTo install the Graphviz using package manager run the following code:\n\nCode: sudo apt install Graphviz # Debian/Ubuntu\nsudo yum install Graphviz # CentOS/RHEL\nsudo pacman -S Graphviz # Arch Linux\n\nTo check if Graphviz is installed, run the code:\n\ndot –V\n\nNow, you have successfully installed Graphviz! Let’s move on to install Diagram library using pip command.\nRun the following code on the terminal:\n\npip install diagrams\n\nCollecting diagrams\n  Using cached diagrams-0.24.1-py3-none-any.whl.metadata (6.9 kB)\nRequirement already satisfied: graphviz&lt;0.21.0,&gt;=0.13.2 in c:\\users\\priya\\appdata\\local\\programs\\python\\python310\\lib\\site-packages (from diagrams) (0.20.3)\nRequirement already satisfied: jinja2&lt;4.0,&gt;=2.10 in c:\\users\\priya\\appdata\\roaming\\python\\python310\\site-packages (from diagrams) (3.1.5)\nRequirement already satisfied: MarkupSafe&gt;=2.0 in c:\\users\\priya\\appdata\\roaming\\python\\python310\\site-packages (from jinja2&lt;4.0,&gt;=2.10-&gt;diagrams) (3.0.2)\nUsing cached diagrams-0.24.1-py3-none-any.whl (25.1 MB)\nInstalling collected packages: diagrams\nSuccessfully installed diagrams-0.24.1\nNote: you may need to restart the kernel to use updated packages.\n\n\nTo upgrade to the latest version of this library run the code:\n\npip install --upgrade diagrams\n\nRequirement already satisfied: diagrams in c:\\users\\priya\\appdata\\local\\programs\\python\\python310\\lib\\site-packages (0.24.1)\nRequirement already satisfied: graphviz&lt;0.21.0,&gt;=0.13.2 in c:\\users\\priya\\appdata\\local\\programs\\python\\python310\\lib\\site-packages (from diagrams) (0.20.3)\nRequirement already satisfied: jinja2&lt;4.0,&gt;=2.10 in c:\\users\\priya\\appdata\\roaming\\python\\python310\\site-packages (from diagrams) (3.1.5)\nRequirement already satisfied: MarkupSafe&gt;=2.0 in c:\\users\\priya\\appdata\\roaming\\python\\python310\\site-packages (from jinja2&lt;4.0,&gt;=2.10-&gt;diagrams) (3.0.2)\nNote: you may need to restart the kernel to use updated packages.\n\n\nTo check if Diagrams is installed correctly, run the following code:\n\nfrom diagrams import Diagram  \nfrom diagrams.aws.compute import EC2  \n\nwith Diagram(\"Simple Diagram\"):  \n    EC2(\"my server\")\n\nHere Simple Diagram is the name of the diagram.\n\n\n\nsimple_diagram.png\n\n\nIf Diagrams is installed successfully then this will generate an image file with single EC2 node drawn as simple_diagram.png in your working directory and open that created image file immediately.\nCore Features\nThe diagrams library consists of four basic things:\n1. Diagram: This acts as the main container that holds all the elements of your architecture visualization. Think of it as a blueprint where you define configurations for your diagram. However, in most cases, all you need to do is provide a name for your diagram. You can create a diagram context with the Diagram class. The first parameter of the Diagram constructor will be used to generate the output filename.\n2. Nodes: Once we define the Diagram context, the next step is to add Nodes, which are the fundamental elements that represent different services and components in your architecture. A Node can be any resource in the system such as:\n\nAn EC2 instance\nA Lambda function\nAn SQS queue\nA Jenkins job, etc.\n\nEach Node belongs to a specific package within the Diagrams library. You can import them as needed. All these nodes can be assigned to variables as well.\nLet’s understand how to use Nodes?\nNodes are imported from different provider categories, such as diagrams.aws.compute, diagrams.onprem.database, etc. A node object consists of three parts: provider, resource type and name. Here is a simple example:\n\nfrom diagrams import Diagram\nfrom diagrams.aws.compute import EC2\n\nwith Diagram(\"Simple Diagram\"):\n    EC2(\"web\")\n\n\n\n\nsimple_diagram-2.png\n\n\nIn this example, EC2 is a node of resource type compute which is provided by the aws provider. Other node objects can also used in similar manner.\n\nfrom diagrams import Diagram\nfrom diagrams.aws.storage import S3\nfrom diagrams.onprem.compute import Server\nfrom diagrams.aws.analytics import Redshift\n\nwith Diagram(\"My Design Diagram\") :\n    DataService = Server(\"Data Service\")\n\n    S3Storage = S3(\"S3 Bucket\")\n\n    MasterDB = Redshift(\"Redshift DW\")\n\nThis code snippet will generate this:\n\n\n\nmy_design_diagram.png\n\n\nOther node objects can also used in similar manner.\n\n# aws resources\nfrom diagrams.aws.compute import ECS, Lambda\nfrom diagrams.aws.database import RDS, ElastiCache\nfrom diagrams.aws.network import ELB, Route53, VPC\n...\n\n# azure resources\nfrom diagrams.azure.compute import FunctionApps\nfrom diagrams.azure.storage import BlobStorage\n...\n\n# alibaba cloud resources\nfrom diagrams.alibabacloud.compute import ECS\nfrom diagrams.alibabacloud.storage import ObjectTableStore\n...\n\n# gcp resources\nfrom diagrams.gcp.compute import AppEngine, GKE\nfrom diagrams.gcp.ml import AutoML\n...\n\n# k8s resources\nfrom diagrams.k8s.compute import Pod, StatefulSet\nfrom diagrams.k8s.network import Service\nfrom diagrams.k8s.storage import PV, PVC, StorageClass\n...\n\n# oracle resources\nfrom diagrams.oci.compute import VirtualMachine, Container\nfrom diagrams.oci.network import Firewall\nfrom diagrams.oci.storage import FileStorage, StorageGateway\n\n****DataFlow****\nData flow can be represented by connecting the nodes with the operators &gt;&gt;, &lt;&lt;, and -.\n&gt;&gt; connects nodes in left to right direction.\n&lt;&lt; connects nodes in right to left direction.\n- connects nodes in no direction. Undirected.\n\nfrom diagrams import Diagram\nfrom diagrams.aws.compute import EC2\nfrom diagrams.aws.database import RDS\nfrom diagrams.aws.network import ELB\nfrom diagrams.aws.storage import S3\n\nwith Diagram(\"Web Services\", show=False):\n    ELB(\"lb\") &gt;&gt; EC2(\"web\") &gt;&gt; RDS(\"userdb\") &gt;&gt; S3(\"store\")\n    ELB(\"lb\") &gt;&gt; EC2(\"web\") &gt;&gt; RDS(\"userdb\") &lt;&lt; EC2(\"stat\")\n    (ELB(\"lb\") &gt;&gt; EC2(\"web\")) - EC2(\"web\") &gt;&gt; RDS(\"userdb\")\n\n\n\n\nweb_services.png\n\n\nNote: Be careful when using ‘-’ and any shift operators together. It can cause unexpected results due to Python’s operator precedence, so you might have to use parentheses.\nThe Data Flow direction can be changed with the direction parameter. The default is LR.\nAllowed values are: TB, BT, LR, and RL\n\nfrom diagrams import Diagram\nfrom diagrams.aws.compute import EC2\nfrom diagrams.aws.database import RDS\nfrom diagrams.aws.network import ELB\n\nwith Diagram(\"Workers\", show=False, direction=\"TB\"):\n    lb = ELB(\"lb\")\n    db = RDS(\"events\")\n    lb &gt;&gt; EC2(\"worker1\") &gt;&gt; db\n    lb &gt;&gt; EC2(\"worker2\") &gt;&gt; db\n    lb &gt;&gt; EC2(\"worker3\") &gt;&gt; db\n    lb &gt;&gt; EC2(\"worker4\") &gt;&gt; db\n    lb &gt;&gt; EC2(\"worker5\") &gt;&gt; db\n\n\n\n\nworkers.png\n\n\n****Group Data Flow****\nTo avoid too many reduntant flows, you can group nodes into a list so that all nodes are connected to other nodes at once:\n\nfrom diagrams import Diagram\nfrom diagrams.aws.compute import EC2\nfrom diagrams.aws.database import RDS\nfrom diagrams.aws.network import ELB\n\nwith Diagram(\"Grouped Workers\", show=False, direction=\"TB\"):\n    ELB(\"lb\") &gt;&gt; [EC2(\"worker1\"),\n                  EC2(\"worker2\"),\n                  EC2(\"worker3\"),\n                  EC2(\"worker4\"),\n                  EC2(\"worker5\")] &gt;&gt; RDS(\"events\")\n\n\n\n\ngrouped_workers.png\n\n\nNote: You can’t connect two lists directly because shift/arithmetic operations between lists are not allowed in Python.\n3. Cluster: A cluster is nothing but a set of nodes that we want together. A cluster is defined using the cluster context and any node defined under that context is grouped together. You can also give it a name to define your cluster group. You can also nest clusters under clusters.\n\nfrom diagrams import Cluster, Diagram\nfrom diagrams.aws.compute import ECS\nfrom diagrams.aws.database import RDS\nfrom diagrams.aws.network import Route53\n\nwith Diagram(\"Simple Web Service with DB Cluster\", show=False):\n    dns = Route53(\"dns\")\n    web = ECS(\"service\")\n\n    with Cluster(\"DB Cluster\"):\n        db_primary = RDS(\"primary\")\n        db_primary - [RDS(\"replica1\"),\n                     RDS(\"replica2\")]\n\n    dns &gt;&gt; web &gt;&gt; db_primary\n\n\n\n\nsimple_web_service_with_db_cluster.png\n\n\n****Nested Cluster:****\n\nfrom diagrams import Cluster, Diagram\nfrom diagrams.aws.compute import ECS, EKS, Lambda\nfrom diagrams.aws.database import Redshift\nfrom diagrams.aws.integration import SQS\nfrom diagrams.aws.storage import S3\n\nwith Diagram(\"Event Processing\", show=False):\n    source = EKS(\"k8s source\")\n\n    with Cluster(\"Event Flows\"):\n        with Cluster(\"Event Workers\"):\n            workers = [ECS(\"worker1\"),\n                       ECS(\"worker2\"),\n                       ECS(\"worker3\")]\n\n        queue = SQS(\"event queue\")\n\n        with Cluster(\"Processing\"):\n            handlers = [Lambda(\"proc1\"),\n                        Lambda(\"proc2\"),\n                        Lambda(\"proc3\")]\n\n    store = S3(\"events store\")\n    dw = Redshift(\"analytics\")\n\n    source &gt;&gt; workers &gt;&gt; queue &gt;&gt; handlers\n    handlers &gt;&gt; store\n    handlers &gt;&gt; dw\n\n\n\n\nevent_processing.png\n\n\n4. Edge: Edge is an object representing a connection between nodes with some additional properties.You can set the colour, label, and style of your edge that connects your nodes. An edge object contains three attributes: label, color, and style. They mirror the corresponding Graphviz edge attributes.\n\nfrom diagrams import Diagram, Edge\nfrom diagrams.aws.storage import S3\nfrom diagrams.onprem.compute import Server\nfrom diagrams.aws.analytics import Redshift\n\nwith Diagram(\"My Design Diagram\") :\n    DataService = Server(\"Data Service\")\n\n    S3Storage = S3(\"S3 Bucket\")\n\n    MasterDB = Redshift(\"Redshift DW\")\n    \n    DataService &gt;&gt; Edge(label=\"Sending data to S3\") &gt;&gt; S3Storage \n    S3Storage &gt;&gt; Edge(label=\"Copying data to Redshift\") &gt;&gt; MasterDB\n\n\n\n\nmy_design_diagram.png\n\n\n\nfrom diagrams import Cluster, Diagram, Edge\nfrom diagrams.onprem.analytics import Spark\nfrom diagrams.onprem.compute import Server\nfrom diagrams.onprem.database import PostgreSQL\nfrom diagrams.onprem.inmemory import Redis\nfrom diagrams.onprem.aggregator import Fluentd\nfrom diagrams.onprem.monitoring import Grafana, Prometheus\nfrom diagrams.onprem.network import Nginx\nfrom diagrams.onprem.queue import Kafka\n\nwith Diagram(name=\"Advanced Web Service with On-Premises (colored)\", show=False):\n    ingress = Nginx(\"ingress\")\n\n    metrics = Prometheus(\"metric\")\n    metrics &lt;&lt; Edge(color=\"firebrick\", style=\"dashed\") &lt;&lt; Grafana(\"monitoring\")\n\n    with Cluster(\"Service Cluster\"):\n        grpcsvc = [\n            Server(\"grpc1\"),\n            Server(\"grpc2\"),\n            Server(\"grpc3\")]\n\n    with Cluster(\"Sessions HA\"):\n        primary = Redis(\"session\")\n        primary \\\n            - Edge(color=\"brown\", style=\"dashed\") \\\n            - Redis(\"replica\") \\\n            &lt;&lt; Edge(label=\"collect\") \\\n            &lt;&lt; metrics\n        grpcsvc &gt;&gt; Edge(color=\"brown\") &gt;&gt; primary\n\n    with Cluster(\"Database HA\"):\n        primary = PostgreSQL(\"users\")\n        primary \\\n            - Edge(color=\"brown\", style=\"dotted\") \\\n            - PostgreSQL(\"replica\") \\\n            &lt;&lt; Edge(label=\"collect\") \\\n            &lt;&lt; metrics\n        grpcsvc &gt;&gt; Edge(color=\"black\") &gt;&gt; primary\n\n    aggregator = Fluentd(\"logging\")\n    aggregator \\\n        &gt;&gt; Edge(label=\"parse\") \\\n        &gt;&gt; Kafka(\"stream\") \\\n        &gt;&gt; Edge(color=\"black\", style=\"bold\") \\\n        &gt;&gt; Spark(\"analytics\")\n\n    ingress \\\n        &gt;&gt; Edge(color=\"darkgreen\") \\\n        &lt;&lt; grpcsvc \\\n        &gt;&gt; Edge(color=\"darkorange\") \\\n        &gt;&gt; aggregator\n\n\n\n\nadvanced_web_service_with_on-premises_(colored).png\n\n\nNow, let’s move forward to understand the relationships between Nodes.\nDirected Relationship: This means a node is pointing towards the next one. Without using edge, you can just use the “&gt;&gt;” operator for this and an arrow will be created between your nodes.\nSynergic Relationship: This is to define nodes that work together as a single unit. You can define this by using the “-” operator between nodes.\n\nfrom diagrams import Diagram, Edge, Cluster\nfrom diagrams.aws.storage import S3\nfrom diagrams.onprem.compute import Server\nfrom diagrams.aws.analytics import Redshift\nfrom diagrams.aws.compute import LambdaFunction as Lambda\n\nwith Diagram(\"My Design Diagram\") :\n    DataService = Server(\"Data Service\")\n\n    with Cluster('S3 Buckets') :\n        S3Storage = [S3(f\"S3 Bucket_{n}\") for n in range(1,4)]\n\n    with Cluster('Lambda Process'):\n        Lambdas = [Lambda(f\"LambdaFunction_{n}\") for n in range(1,4)]\n\n        for n in range(0,2):\n            Lambdas[n] - Lambdas[n+1]\n\n\n\n    MasterDB = Redshift(\"Redshift DW\")\n\n    DataService &gt;&gt; Edge(label=\"Sending data to S3\") &gt;&gt; S3Storage\n    S3Storage &gt;&gt; Edge(label=\"Copying data to Redshift\") &gt;&gt; MasterDB\n    MasterDB &gt;&gt; Lambdas\n\n\n\n\nmy_design_diagram.png\n\n\nHere we have defined the relationship between the lambda function using the ‘-’ operator and so they are now in synergic relationshi and work together inside the cluster. It can be seen from here that how the Redshift DW directed to the Lambda functions without any text defining a directed relationship by just using the ‘&gt;&gt;’ operator without any Edge.\nAdvanced Features & Customizations\nNow that you’ve covered the basics (Diagram, Nodes, Edges, Clusters, and Relationships), let’s introduce more customization options. One of the standout features of the Diagrams library is its simple and intuitive Python syntax.Diagrams allows users to define infrastructure, system architecture, and cloud diagrams using concise Python code. These are the key features of the Diagram library:\n1. Customizing Node Styles: Diagrams allow you to customize node styles, including color, shape, and icons, to enhance clarity and visual appeal.\n\nfrom diagrams import Diagram\nfrom diagrams.aws.compute import EC2\nfrom diagrams.aws.database import RDS\nfrom diagrams.aws.network import ELB\n\nwith Diagram(\"Custom Styled Nodes\", show=True, direction=\"TB\"):\n    lb = ELB(\"Load Balancer\")  # Default AWS icon\n    web = EC2(\"Web Server\")  # EC2 icon\n    db = RDS(\"Database\")  # Database icon\n\n    lb - [web] - db  # Defining connections\n\n\n\n\ncustom_styled_nodes.png\n\n\n2. Using Subgraphs for Better Organization: Subgraphs (Clusters) help group related components in a diagram, making it easier to understand complex systems.\n\nfrom diagrams import Diagram, Cluster\nfrom diagrams.aws.compute import EC2\nfrom diagrams.aws.database import RDS\nfrom diagrams.aws.network import ELB\n\nwith Diagram(\"Grouped Architecture\", show=True, direction=\"TB\"):\n    lb = ELB(\"Load Balancer\")\n\n    with Cluster(\"Application Servers\"):\n        web1 = EC2(\"Web Server 1\")\n        web2 = EC2(\"Web Server 2\")\n\n    db = RDS(\"Database\")\n\n    lb - [web1, web2] - db  # Connecting nodes\n\n\n\n\ngrouped_architecture.png\n\n\n3. Arranging Layouts: By default, Diagrams arranges components top to bottom (TB), but you can customize it using direction attributes:\n\nTB (Top to Bottom)\nLR (Left to Right)\nBT (Bottom to Top)\nRL (Right to Left)\n\nExample : Left-to-Right (LR) Layout\n\nfrom diagrams import Diagram\nfrom diagrams.aws.compute import EC2\nfrom diagrams.aws.database import RDS\nfrom diagrams.aws.network import ELB\n\nwith Diagram(\"Left to Right Layout\", direction=\"LR\", show=True):\n    lb = ELB(\"Load Balancer\")\n    web = EC2(\"Web Server\")\n    db = RDS(\"Database\")\n\n    lb &gt;&gt; web &gt;&gt; db  # Flow from left to right\n\n\n\n\nleft_to_right_layout.png\n\n\n4. Adding Custom Icons and Images: By default, Diagrams uses built-in icons, but you can use custom images for non-supported components.\n\nfrom diagrams import Diagram\nfrom diagrams.custom import Custom\n\nwith Diagram(\"Custom Icon Example\", show=True):\n    my_service = Custom(\"My Service\", \"./my_icon.png\")\n\n\n\n\ncustom_icon_example.png\n\n\n5. Defining Complex Relationships (Bidirectional & Conditional Arrows): This helps represent data flow, feedback loops, and interdependencies.\n\nfrom diagrams import Diagram\nfrom diagrams.aws.compute import EC2\nfrom diagrams.aws.database import RDS\nfrom diagrams.aws.network import ELB\n\nwith Diagram(\"Complex Relationships\", show=True):\n    lb = ELB(\"Load Balancer\")\n    web = EC2(\"Web Server\")\n    db = RDS(\"Database\")\n\n    lb &gt;&gt; web  # One-way connection\n    web &gt;&gt; db  # One-way connection\n    db &lt;&lt; web  # Bidirectional connection (data flow)\n\n\n\n\ncomplex_relationships.png\n\n\n6. Using Different Providers (AWS, GCP, Azure, On-Premises): Diagrams supports multiple cloud providers and on-premises infrastructure.\n\nfrom diagrams import Diagram\nfrom diagrams.aws.compute import EC2\nfrom diagrams.azure.compute import AppServices\nfrom diagrams.gcp.compute import GCE\nfrom diagrams.onprem.database import PostgreSQL\n\nwith Diagram(\"Multi-Cloud Setup\", show=True):\n    aws_vm = EC2(\"AWS EC2\")\n    azure_func = AppServices(\"Azure App Service\")\n    gcp_vm = GCE(\"GCP Compute Engine\")\n    onprem_db = PostgreSQL(\"On-Prem Database\")\n\n    aws_vm &gt;&gt; azure_func &gt;&gt; gcp_vm &gt;&gt; onprem_db\n\n\n\n\nmulti-cloud_setup.png\n\n\n7. Prebuilt Cloud and On-Prem Components : The Diagrams library provides prebuilt cloud and on-prem components that allow users to easily create infrastructure diagrams without designing custom icons or shapes. These components represent various cloud services, networking elements, storage, databases, and security tools from providers like AWS,Azure, Google Cloud, and on-prem architectures.\n\n\n\n\n\n\n\nCategory\nSupported Services\n\n\n\n\nCloud Providers\nAWS, Azure, GCP, OpenStack, Alibaba Cloud\n\n\nDevOps Tools\nKubernetes, Terraform, Jenkins, GitHub Actions\n\n\nNetworking\nCisco, F5, Juniper routers and firewalls\n\n\nOn-Premise\nGeneric servers, databases, load balancers\n\n\n\n8. Exporting and Saving Diagrams: Once you create a diagram using the Diagrams(mingrammer/diagrams) library, you may need to export, save, or share it in different formats. The library automatically generates an image file when the diagram script runs, but you can customize the output file format,location, and visualization options. Example: Save as SVG\n\nfrom diagrams import Diagram\nfrom diagrams.aws.compute import EC2\n\nwith Diagram(\"Custom_Diagram\", filename=\"my_diagram\", outformat=\"svg\"):\n    EC2(\"Web Server\")  \n\nSummary of Advanced Features\n\n\n\n\n\n\n\nFeature\nDescription & Use Case\n\n\n\n\nCustom Icons\nUse custom images for branding or non-supported tools.\n\n\nRelationships\nDefine one-way, bidirectional, and feedback loop connections.\n\n\nMulti-Cloud Support\nConnect AWS, Azure, GCP, and on-prem services.\n\n\nExporting Diagrams\nSave diagrams as PNG, SVG, PDF, or JPG.\n\n\nCI/CD Integration\nAutomate diagram generation in pipelines.\n\n\n\nBest Practices & Tips for Creating Diagrams:\n\nKeep it Simple – Avoid overcrowding diagrams with unnecessary components.\nUse Clusters – Organize diagrams into meaningful groups.\nLabel Components Properly – Use descriptive names for better clarity.\nUse Version Control – Store diagrams in GitHub to track changes over time.\nOptimize Layouts – Choose the best direction (TB, LR, RL, BT) for readability.\n\nReal world Use-Cases\n1. Cloud Architecture Visualization - Helps in designing and documenting cloud architectures across platforms like AWS, GCP, Azure, Kubernetes, Alibaba Cloud and Oracle Cloud.\n\nExample – Generates AWS network topology diagrams programmatically.\n\nBenefits: Automates cloud architecture documentation, ensuring up-to-date diagrams.\n\n2. Software System Design - Engineers and architects can expertly create flowcharts for software modules, microservices, and APIs.\n\nExample: Clearly representing data flow in a microservices-based application.\n\nBenefits: Provides clear system design documentation.\n\n3. Hybrid Cloud and Multi-Cloud Architecture - Helps architects visualize hybrid cloud (on-prem + cloud) and multi-cloud (AWS + GCP + Azure) environments.\n\nExample: Hybrid cloud infrastructure with AWS and on-premises resources.\nBenefits: Helps organizations design failover and disaster recovery plans.\n\n4. Security Architecture Visualization - Useful for compliance and security reviews (ISO, NIST, SOC2). - - Example: Security Architecture for a Web Application. - - Benefits: Helps organizations comply with security policies and audits (ISO, SOC2, NIST).\nReferences\n\nmingrammer/diagrams GitHub Repository\n\n\nURL: https://github.com/mingrammer/diagrams\nDescription: Official GitHub repository with source code, examples, and documentation.\n\n\nmingrammer/diagrams Documentation\n\n\nURL: https://diagrams.mingrammer.com\nDescription: Official documentation explaining installation and usage.\n\n\nYouTube – Python Diagrams for DevOps and Cloud Architecture\n\n\nhttps://youtu.be/Oa-_EUg44cQ?feature=shared\n\nConclusion:\n\nThe mingrammer/diagrams library stands out as a powerful and versatile tool designed for users who need to create diagrams related to infrastructure, software, and networks using Python code.\nThis library offers a significant advantage over traditional diagramming tools like Microsoft Visio or Draw.io by automating the diagramming process.\nAs a result, it ensures that the system architecture remains consistent, up-to-date, and easily version-controlled, providing a streamlined approach to diagram creation.\n\nChallenges:\n\nRequires basic Python knowledge for scripting diagrams.\nLimited styling options compared to UI-based tools.\nUnlike Google Drawings or Miro, diagrams lacks real-time team collaboration features."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Exposition Assignment PSDV",
    "section": "",
    "text": "Assignment Done by Group J040!"
  }
]