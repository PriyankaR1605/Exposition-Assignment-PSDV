<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.6.42">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>psdv-assignment-blog – Quarto Template</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../site_libs/clipboard/clipboard.min.js"></script>
<script src="../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../site_libs/quarto-search/fuse.min.js"></script>
<script src="../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../">
<script src="../site_libs/quarto-html/quarto.js"></script>
<script src="../site_libs/quarto-html/popper.min.js"></script>
<script src="../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../site_libs/quarto-html/anchor.min.js"></script>
<link href="../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../site_libs/quarto-html/quarto-syntax-highlighting-8e00f2f28a1266a720913de837032221.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../site_libs/bootstrap/bootstrap-7cfa380d139a4d61a924487b0af32b39.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>


</head>

<body class="nav-fixed fullcontent">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../index.html">
    <span class="navbar-title">Quarto Template</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../index.html"> 
<span class="menu-text">Home</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../blog.html"> 
<span class="menu-text">Blog</span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    
<!-- main -->
<main class="content" id="quarto-document-content"><header id="title-block-header" class="quarto-title-block"></header>




<p><strong>STOP DRAWING START CODING : Automating Architecture Diagrams with mingrammer/diagrams</strong></p>
<p>Ever spent hours perfecting an architecture diagram, only to have one tiny system update throw everything off? Sounds frustrating, right? What if you could generate professional, scalable, and dynamic system diagrams, just by writing a few lines of Python code?</p>
<p><strong>Welcome to mingrammer/diagrams</strong>—a powerful Python library that lets you create cloud, DevOps, and infrastructure diagrams effortlessly!</p>
<ul>
<li><p>No more dragging and tweaking of shapes.</p></li>
<li><p>No more struggling with alignment.</p></li>
<li><p>No more outdated documentation.</p></li>
</ul>
<p>With Diagrams, you can now turn your code into accurate, stunning and professional system diagrams within seconds. In this blog, we’ll explore the following areas:</p>
<ul>
<li><p>Introduction to Diagrams</p></li>
<li><p>Installation setup</p></li>
<li><p>Core features</p></li>
<li><p>Advanced features</p></li>
<li><p>Real-world use cases</p></li>
<li><p>More references</p></li>
<li><p>Conclusion</p></li>
</ul>
<p><strong><em>Prerequisites</em></strong></p>
<p><strong>Python:</strong> This versatile programming language will serve as our trusty companion throughout the process. Ensure to install python version 3.7 or above.</p>
<p><strong><em>Introduction</em></strong></p>
<p>In early 2020, python library Diagrams was created by a Korean developer MinJae Kwon. This Python-based library allows developers to generate professional system diagrams with just few lines of code. With Diagrams, you can create AWS, GCP, Kubernetes, On-Prem, and SaaS infrastructure diagrams programmatically, making it an excellent tool for DevOps engineers, cloud architects, and system designers.</p>
<p><strong>What is Diagrams?</strong></p>
<p>Diagrams is an open-source Python library that allows you to generate architecture diagrams programmatically. Instead of dragging and dropping elements in a diagramming tool, you can write simple Python code to create cloud architecture, microservices, and DevOps pipeline diagrams.</p>
<p><strong>What is “Diagrams as Code”?</strong></p>
<p>The concept of “Diagrams as Code” refers to automating the process of diagram generation using code instead of manually designing visuals. Just like Infrastructure as Code (IaC) automates cloud provisioning, Diagrams as Code makes system documentation easier, scalable, and version-controlled.</p>
<table class="caption-top table">
<colgroup>
<col style="width: 27%">
<col style="width: 28%">
<col style="width: 43%">
</colgroup>
<thead>
<tr class="header">
<th><strong>Aspect</strong></th>
<th><strong>Manual Approach</strong></th>
<th><strong>Diagrams as Code Approach</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><strong>Creation Method</strong></td>
<td>Manually design diagrams using <strong>Visio, Lucidchart, Draw.io</strong></td>
<td>Write <strong>Python scripts</strong> to generate diagrams programmatically</td>
</tr>
<tr class="even">
<td><strong>Maintenance</strong></td>
<td>Difficult to update and maintain when system changes</td>
<td><strong>Easily editable and reusable</strong>—update with code changes</td>
</tr>
<tr class="odd">
<td><strong>Accuracy</strong></td>
<td>Prone to <strong>human errors</strong> and inconsistencies</td>
<td>Ensures <strong>precision and consistency</strong></td>
</tr>
<tr class="even">
<td><strong>Collaboration</strong></td>
<td>Hard to track changes in team projects</td>
<td><strong>Version-controlled</strong> with GitHub/GitLab</td>
</tr>
<tr class="odd">
<td><strong>Automation</strong></td>
<td>No automation—manual updates required</td>
<td><strong>Real-time updates</strong> with automated documentation</td>
</tr>
</tbody>
</table>
<p><strong><em>Now let’s see how to install and setup Diagrams in Python</em></strong></p>
<p><strong>Before installing Diagrams you need to install:</strong></p>
<ul>
<li><p><strong>Python 3.7+</strong> (https://www.python.org/downloads/)</p></li>
<li><p><strong>Graphviz</strong></p></li>
</ul>
<p>Graphviz (Graph Visualization Software) is an open-source tool used for generating diagrams and graphs from text-based descriptions. It is widely used for network diagrams, architecture visualization, dependency graphs, and flowcharts.</p>
<p>Why is Graphviz Important?</p>
<p> Required by Diagrams (mingrammer/diagrams) for rendering visuals.</p>
<p> Automatic layout generation (arranges nodes and edges efficiently).</p>
<p> Supports multiple formats (PNG, SVG, PDF, etc).</p>
<p> Integrates with Python, C, Java, etc.</p>
<p><strong>To Install Graphviz:</strong></p>
<ul>
<li><strong>For Window Users:</strong></li>
</ul>
<ol type="1">
<li><p>Download and install Graphviz.</p></li>
<li><p>Add Graphviz to the system PATH variable. o Open System Properties . o Go to the Advanced tab then Click on the Environment Variables. o Under System Variables, find Path, click Edit. o Add the Graphviz bin directory path, which is usually: C: Files Then Click OK and restart your terminal.</p></li>
<li><p>Check that the Graphviz is installed by running the following code:</p></li>
</ol>
<p>dot -V</p>
<p>If Graphviz is installed correctly, you must see the output as follows:</p>
<p>dot - Graphviz version 2.49.3 (2025-02-22)</p>
<ul>
<li><strong>For macOS Users:</strong></li>
</ul>
<p>To install Graphviz by using homebrew run the code:</p>
<p>brew install Graphviz</p>
<p>To check that the Graphviz is installed, run the code:</p>
<p>dot –V</p>
<p>If the output is as follows, then you have istalled Graphviz successfully!</p>
<p>dot - Graphviz version 2.49.3</p>
<ul>
<li><strong>For Linux Users:</strong></li>
</ul>
<p>To install the Graphviz using package manager run the following code:</p>
<p>Code: sudo apt install Graphviz # Debian/Ubuntu sudo yum install Graphviz # CentOS/RHEL sudo pacman -S Graphviz # Arch Linux</p>
<p>To check if Graphviz is installed, run the code:</p>
<p>dot –V</p>
<p>Now, you have successfully installed Graphviz! Let’s move on to install Diagram library using pip command.</p>
<p>Run the following code on the terminal:</p>
<p>pip install diagrams</p>
<p>To upgrade to the latest version of this library run the code:</p>
<p>pip install –upgrade diagrams</p>
<p>To check if Diagrams is installed correctly, run the following code:</p>
<p>from diagrams import Diagram<br>
from diagrams.aws.compute import EC2</p>
<p>with Diagram(“Simple Diagram”):<br>
EC2(“my server”)</p>
<p>Here Simple Diagram is the name of the diagram. If you run the above code with the command below,</p>
<p>$ python diagram.py</p>
<p>If Diagrams is installed successfully then this will generate an image file with single EC2 node drawn as simple_diagram.png in your working directory and open that created image file immediately.</p>
<p><strong><em>Core Features</em></strong></p>
<p>The diagrams library consists of four basic things:</p>
<p><strong>1. Diagram:</strong> This acts as the main container that holds all the elements of your architecture visualization. Think of it as a blueprint where you define configurations for your diagram. However, in most cases, all you need to do is provide a name for your diagram. You can create a diagram context with the Diagram class. The first parameter of the Diagram constructor will be used to generate the output filename.</p>
<p><strong>2. Nodes:</strong> Once we define the Diagram context, the next step is to add Nodes, which are the fundamental elements that represent different services and components in your architecture. A Node can be any resource in the system such as:</p>
<ul>
<li><p>An EC2 instance</p></li>
<li><p>A Lambda function</p></li>
<li><p>An SQS queue</p></li>
<li><p>A Jenkins job, etc.</p></li>
</ul>
<p>Each Node belongs to a specific package within the Diagrams library. You can import them as needed. All these nodes can be assigned to variables as well.</p>
<p><strong>Let’s understand how to use Nodes?</strong></p>
<p>Nodes are imported from different provider categories, such as diagrams.aws.compute, diagrams.onprem.database, etc. A node object consists of three parts: provider, resource type and name. Here is a simple example:</p>
<p>from diagrams import Diagram from diagrams.aws.compute import EC2</p>
<p>with Diagram(“Simple Diagram”): EC2(“web”)</p>
<p>In this example, EC2 is a node of resource type compute which is provided by the aws provider. Other node objects can also used in similar manner.</p>
<p>from diagrams import Diagram from diagrams.aws.storage import S3 from diagrams.onprem.compute import Server from diagrams.aws.analytics import Redshift</p>
<p>with Diagram(“My Design Diagram”) : DataService = Server(“Data Service”)</p>
<pre><code>S3Storage = S3("S3 Bucket")

MasterDB = Redshift("Redshift DW")</code></pre>
<p>This code snippet will generate this:</p>
<p>Other node objects can also used in similar manner.</p>
<section id="aws-resources" class="level1">
<h1>aws resources</h1>
<p>from diagrams.aws.compute import ECS, Lambda from diagrams.aws.database import RDS, ElastiCache from diagrams.aws.network import ELB, Route53, VPC …</p>
</section>
<section id="azure-resources" class="level1">
<h1>azure resources</h1>
<p>from diagrams.azure.compute import FunctionApps from diagrams.azure.storage import BlobStorage …</p>
</section>
<section id="alibaba-cloud-resources" class="level1">
<h1>alibaba cloud resources</h1>
<p>from diagrams.alibabacloud.compute import ECS from diagrams.alibabacloud.storage import ObjectTableStore …</p>
</section>
<section id="gcp-resources" class="level1">
<h1>gcp resources</h1>
<p>from diagrams.gcp.compute import AppEngine, GKE from diagrams.gcp.ml import AutoML …</p>
</section>
<section id="k8s-resources" class="level1">
<h1>k8s resources</h1>
<p>from diagrams.k8s.compute import Pod, StatefulSet from diagrams.k8s.network import Service from diagrams.k8s.storage import PV, PVC, StorageClass …</p>
</section>
<section id="oracle-resources" class="level1">
<h1>oracle resources</h1>
<p>from diagrams.oci.compute import VirtualMachine, Container from diagrams.oci.network import Firewall from diagrams.oci.storage import FileStorage, StorageGateway</p>
<p>****DataFlow****</p>
<p>Data flow can be represented by connecting the nodes with the operators &gt;&gt;, &lt;&lt;, and -.</p>
<p><strong>&gt;&gt;</strong> connects nodes in left to right direction.</p>
<p><strong>&lt;&lt;</strong> connects nodes in right to left direction.</p>
<p><strong>-</strong> connects nodes in no direction. Undirected.</p>
<p>from diagrams import Diagram from diagrams.aws.compute import EC2 from diagrams.aws.database import RDS from diagrams.aws.network import ELB from diagrams.aws.storage import S3</p>
<p>with Diagram(“Web Services”, show=False): ELB(“lb”) &gt;&gt; EC2(“web”) &gt;&gt; RDS(“userdb”) &gt;&gt; S3(“store”) ELB(“lb”) &gt;&gt; EC2(“web”) &gt;&gt; RDS(“userdb”) &lt;&lt; EC2(“stat”) (ELB(“lb”) &gt;&gt; EC2(“web”)) - EC2(“web”) &gt;&gt; RDS(“userdb”)</p>
<p><strong>Note:</strong> Be careful when using ‘-’ and any shift operators together. It can cause unexpected results due to Python’s operator precedence, so you might have to use parentheses.</p>
<p>The Data Flow direction can be changed with the direction parameter. The default is LR.</p>
<p>Allowed values are: TB, BT, LR, and RL</p>
<p>from diagrams import Diagram from diagrams.aws.compute import EC2 from diagrams.aws.database import RDS from diagrams.aws.network import ELB</p>
<p>with Diagram(“Workers”, show=False, direction=“TB”): lb = ELB(“lb”) db = RDS(“events”) lb &gt;&gt; EC2(“worker1”) &gt;&gt; db lb &gt;&gt; EC2(“worker2”) &gt;&gt; db lb &gt;&gt; EC2(“worker3”) &gt;&gt; db lb &gt;&gt; EC2(“worker4”) &gt;&gt; db lb &gt;&gt; EC2(“worker5”) &gt;&gt; db</p>
<p>****Group Data Flow****</p>
<p>To avoid too many reduntant flows, you can group nodes into a list so that all nodes are connected to other nodes at once:</p>
<p>from diagrams import Diagram from diagrams.aws.compute import EC2 from diagrams.aws.database import RDS from diagrams.aws.network import ELB</p>
<p>with Diagram(“Grouped Workers”, show=False, direction=“TB”): ELB(“lb”) &gt;&gt; [EC2(“worker1”), EC2(“worker2”), EC2(“worker3”), EC2(“worker4”), EC2(“worker5”)] &gt;&gt; RDS(“events”)</p>
<p><strong>Note:</strong> You can’t connect two lists directly because shift/arithmetic operations between lists are not allowed in Python.</p>
<p><strong>3. Cluster:</strong> A cluster is nothing but a set of nodes that we want together. A cluster is defined using the cluster context and any node defined under that context is grouped together. You can also give it a name to define your cluster group. You can also nest clusters under clusters.</p>
<p>from diagrams import Cluster, Diagram from diagrams.aws.compute import ECS from diagrams.aws.database import RDS from diagrams.aws.network import Route53</p>
<p>with Diagram(“Simple Web Service with DB Cluster”, show=False): dns = Route53(“dns”) web = ECS(“service”)</p>
<pre><code>with Cluster("DB Cluster"):
    db_primary = RDS("primary")
    db_primary - [RDS("replica1"),
                 RDS("replica2")]

dns &gt;&gt; web &gt;&gt; db_primary</code></pre>
<p>****Nested Cluster:****</p>
<p>from diagrams import Cluster, Diagram from diagrams.aws.compute import ECS, EKS, Lambda from diagrams.aws.database import Redshift from diagrams.aws.integration import SQS from diagrams.aws.storage import S3</p>
<p>with Diagram(“Event Processing”, show=False): source = EKS(“k8s source”)</p>
<pre><code>with Cluster("Event Flows"):
    with Cluster("Event Workers"):
        workers = [ECS("worker1"),
                   ECS("worker2"),
                   ECS("worker3")]

    queue = SQS("event queue")

    with Cluster("Processing"):
        handlers = [Lambda("proc1"),
                    Lambda("proc2"),
                    Lambda("proc3")]

store = S3("events store")
dw = Redshift("analytics")

source &gt;&gt; workers &gt;&gt; queue &gt;&gt; handlers
handlers &gt;&gt; store
handlers &gt;&gt; dw</code></pre>
<p><strong>4. Edge:</strong> Edge is an object representing a connection between nodes with some additional properties.You can set the colour, label, and style of your edge that connects your nodes. An edge object contains three attributes: label, color, and style. They mirror the corresponding Graphviz edge attributes.</p>
<p>from diagrams import Diagram, Edge from diagrams.aws.storage import S3 from diagrams.onprem.compute import Server from diagrams.aws.analytics import Redshift</p>
<p>with Diagram(“My Design Diagram”) : DataService = Server(“Data Service”)</p>
<pre><code>S3Storage = S3("S3 Bucket")

MasterDB = Redshift("Redshift DW")

DataService &gt;&gt; Edge(label="Sending data to S3") &gt;&gt; S3Storage 
S3Storage &gt;&gt; Edge(label="Copying data to Redshift") &gt;&gt; MasterDB</code></pre>
<p>from diagrams import Cluster, Diagram, Edge from diagrams.onprem.analytics import Spark from diagrams.onprem.compute import Server from diagrams.onprem.database import PostgreSQL from diagrams.onprem.inmemory import Redis from diagrams.onprem.aggregator import Fluentd from diagrams.onprem.monitoring import Grafana, Prometheus from diagrams.onprem.network import Nginx from diagrams.onprem.queue import Kafka</p>
<p>with Diagram(name=“Advanced Web Service with On-Premises (colored)”, show=False): ingress = Nginx(“ingress”)</p>
<pre><code>metrics = Prometheus("metric")
metrics &lt;&lt; Edge(color="firebrick", style="dashed") &lt;&lt; Grafana("monitoring")

with Cluster("Service Cluster"):
    grpcsvc = [
        Server("grpc1"),
        Server("grpc2"),
        Server("grpc3")]

with Cluster("Sessions HA"):
    primary = Redis("session")
    primary \
        - Edge(color="brown", style="dashed") \
        - Redis("replica") \
        &lt;&lt; Edge(label="collect") \
        &lt;&lt; metrics
    grpcsvc &gt;&gt; Edge(color="brown") &gt;&gt; primary

with Cluster("Database HA"):
    primary = PostgreSQL("users")
    primary \
        - Edge(color="brown", style="dotted") \
        - PostgreSQL("replica") \
        &lt;&lt; Edge(label="collect") \
        &lt;&lt; metrics
    grpcsvc &gt;&gt; Edge(color="black") &gt;&gt; primary

aggregator = Fluentd("logging")
aggregator \
    &gt;&gt; Edge(label="parse") \
    &gt;&gt; Kafka("stream") \
    &gt;&gt; Edge(color="black", style="bold") \
    &gt;&gt; Spark("analytics")

ingress \
    &gt;&gt; Edge(color="darkgreen") \
    &lt;&lt; grpcsvc \
    &gt;&gt; Edge(color="darkorange") \
    &gt;&gt; aggregator</code></pre>
<p>Now, let’s move forward to understand the relationships between Nodes.</p>
<p><strong>Directed Relationship:</strong> This means a node is pointing towards the next one. Without using edge, you can just use the “&gt;&gt;” operator for this and an arrow will be created between your nodes.</p>
<p><strong>Synergic Relationship:</strong> This is to define nodes that work together as a single unit. You can define this by using the “-” operator between nodes.</p>
<p>from diagrams import Diagram, Edge, Cluster from diagrams.aws.storage import S3 from diagrams.onprem.compute import Server from diagrams.aws.analytics import Redshift from diagrams.aws.compute import LambdaFunction as Lambda</p>
<p>with Diagram(“My Design Diagram”) : DataService = Server(“Data Service”)</p>
<pre><code>with Cluster('S3 Buckets') :
    S3Storage = [S3(f"S3 Bucket_{n}") for n in range(1,4)]

with Cluster('Lambda Process'):
    Lambdas = [Lambda(f"LambdaFunction_{n}") for n in range(1,4)]

    for n in range(0,2):
        Lambdas[n] - Lambdas[n+1]



MasterDB = Redshift("Redshift DW")

DataService &gt;&gt; Edge(label="Sending data to S3") &gt;&gt; S3Storage
S3Storage &gt;&gt; Edge(label="Copying data to Redshift") &gt;&gt; MasterDB
MasterDB &gt;&gt; Lambdas</code></pre>
<p>Here we have defined the relationship between the lambda function using the ‘-’ operator and so they are now in synergic relationshi and work together inside the cluster. It can be seen from here that how the Redshift DW directed to the Lambda functions without any text defining a directed relationship by just using the ‘&gt;&gt;’ operator without any Edge.</p>
<p><strong><em>Advanced Features &amp; Customizations</em></strong></p>
<p>Now that you’ve covered the basics (Diagram, Nodes, Edges, Clusters, and Relationships), let’s introduce more customization options. One of the standout features of the Diagrams library is its simple and intuitive Python syntax.Diagrams allows users to define infrastructure, system architecture, and cloud diagrams using concise Python code. These are the key features of the Diagram library:</p>
<p><strong>1. Customizing Node Styles:</strong> Diagrams allow you to customize node styles, including color, shape, and icons, to enhance clarity and visual appeal.</p>
<p>from diagrams import Diagram from diagrams.aws.compute import EC2 from diagrams.aws.database import RDS from diagrams.aws.network import ELB</p>
<p>with Diagram(“Custom Styled Nodes”, show=True, direction=“TB”): lb = ELB(“Load Balancer”) # Default AWS icon web = EC2(“Web Server”) # EC2 icon db = RDS(“Database”) # Database icon</p>
<pre><code>lb - [web] - db  # Defining connections</code></pre>
<p><strong>2. Using Subgraphs for Better Organization:</strong> Subgraphs (Clusters) help group related components in a diagram, making it easier to understand complex systems.</p>
<p>from diagrams import Diagram, Cluster from diagrams.aws.compute import EC2 from diagrams.aws.database import RDS from diagrams.aws.network import ELB</p>
<p>with Diagram(“Grouped Architecture”, show=True, direction=“TB”): lb = ELB(“Load Balancer”)</p>
<pre><code>with Cluster("Application Servers"):
    web1 = EC2("Web Server 1")
    web2 = EC2("Web Server 2")

db = RDS("Database")

lb - [web1, web2] - db  # Connecting nodes</code></pre>
<p><strong>3. Arranging Layouts:</strong> By default, Diagrams arranges components top to bottom (TB), but you can customize it using direction attributes:</p>
<ul>
<li><p>TB (Top to Bottom)</p></li>
<li><p>LR (Left to Right)</p></li>
<li><p>BT (Bottom to Top)</p></li>
<li><p>RL (Right to Left)</p></li>
</ul>
<p>Example : Left-to-Right (LR) Layout</p>
<p>from diagrams import Diagram from diagrams.aws.compute import EC2 from diagrams.aws.database import RDS from diagrams.aws.network import ELB</p>
<p>with Diagram(“Left to Right Layout”, direction=“LR”, show=True): lb = ELB(“Load Balancer”) web = EC2(“Web Server”) db = RDS(“Database”)</p>
<pre><code>lb &gt;&gt; web &gt;&gt; db  # Flow from left to right</code></pre>
<p><strong>4. Adding Custom Icons and Images:</strong> By default, Diagrams uses built-in icons, but you can use custom images for non-supported components.</p>
<p>from diagrams import Diagram from diagrams.custom import Custom</p>
<p>with Diagram(“Custom Icon Example”, show=True): my_service = Custom(“My Service”, “./my_icon.png”)</p>
<p><strong>5. Defining Complex Relationships (Bidirectional &amp; Conditional Arrows):</strong> This helps represent data flow, feedback loops, and interdependencies.</p>
<p>from diagrams import Diagram from diagrams.aws.compute import EC2 from diagrams.aws.database import RDS from diagrams.aws.network import ELB</p>
<p>with Diagram(“Complex Relationships”, show=True): lb = ELB(“Load Balancer”) web = EC2(“Web Server”) db = RDS(“Database”)</p>
<pre><code>lb &gt;&gt; web  # One-way connection
web &gt;&gt; db  # One-way connection
db &lt;&lt; web  # Bidirectional connection (data flow)</code></pre>
<p><strong>6. Using Different Providers (AWS, GCP, Azure, On-Premises):</strong> Diagrams supports multiple cloud providers and on-premises infrastructure.</p>
<p>from diagrams import Diagram from diagrams.aws.compute import EC2 from diagrams.azure.compute import FunctionApp from diagrams.gcp.compute import GCE from diagrams.onprem.database import PostgreSQL</p>
<p>with Diagram(“Multi-Cloud Setup”, show=True): aws_vm = EC2(“AWS EC2”) azure_func = FunctionApp(“Azure Function”) gcp_vm = GCE(“GCP Compute Engine”) onprem_db = PostgreSQL(“On-Prem Database”)</p>
<pre><code>aws_vm &gt;&gt; azure_func &gt;&gt; gcp_vm &gt;&gt; onprem_db</code></pre>
<p><strong>7. Prebuilt Cloud and On-Prem Components :</strong> The Diagrams library provides prebuilt cloud and on-prem components that allow users to easily create infrastructure diagrams without designing custom icons or shapes. These components represent various cloud services, networking elements, storage, databases, and security tools from providers like AWS,Azure, Google Cloud, and on-prem architectures.</p>
<table class="caption-top table">
<colgroup>
<col style="width: 22%">
<col style="width: 77%">
</colgroup>
<thead>
<tr class="header">
<th>Category</th>
<th>Supported Services</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Cloud Providers</td>
<td>AWS, Azure, GCP, OpenStack, Alibaba Cloud</td>
</tr>
<tr class="even">
<td>DevOps Tools</td>
<td>Kubernetes, Terraform, Jenkins, GitHub Actions</td>
</tr>
<tr class="odd">
<td>Networking</td>
<td>Cisco, F5, Juniper routers and firewalls</td>
</tr>
<tr class="even">
<td>On-Premise</td>
<td>Generic servers, databases, load balancers</td>
</tr>
</tbody>
</table>
<p><strong>8. Exporting and Saving Diagrams:</strong> Once you create a diagram using the Diagrams(mingrammer/diagrams) library, you may need to export, save, or share it in different formats. The library automatically generates an image file when the diagram script runs, but you can customize the output file format,location, and visualization options. Example: Save as SVG</p>
<p>from diagrams import Diagram from diagrams.aws.compute import EC2 with Diagram("Custom_Diagram", filename="my_diagram", outformat="svg"): EC2("Web Server")</p>
<p><strong>Summary of Advanced Features</strong></p>
<table class="caption-top table">
<colgroup>
<col style="width: 26%">
<col style="width: 73%">
</colgroup>
<thead>
<tr class="header">
<th>Feature</th>
<th>Description &amp; Use Case</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><strong>Custom Icons</strong></td>
<td>Use custom images for branding or non-supported tools.</td>
</tr>
<tr class="even">
<td><strong>Relationships</strong></td>
<td>Define one-way, bidirectional, and feedback loop connections.</td>
</tr>
<tr class="odd">
<td><strong>Multi-Cloud Support</strong></td>
<td>Connect AWS, Azure, GCP, and on-prem services.</td>
</tr>
<tr class="even">
<td><strong>Exporting Diagrams</strong></td>
<td>Save diagrams as PNG, SVG, PDF, or JPG.</td>
</tr>
<tr class="odd">
<td><strong>CI/CD Integration</strong></td>
<td>Automate diagram generation in pipelines.</td>
</tr>
</tbody>
</table>
<p><strong><em>Best Practices &amp; Tips for Creating Diagrams:</em></strong></p>
<ul>
<li><p>Keep it Simple – Avoid overcrowding diagrams with unnecessary components.</p></li>
<li><p>Use Clusters – Organize diagrams into meaningful groups.</p></li>
<li><p>Label Components Properly – Use descriptive names for better clarity.</p></li>
<li><p>Use Version Control – Store diagrams in GitHub to track changes over time.</p></li>
<li><p>Optimize Layouts – Choose the best direction (TB, LR, RL, BT) for readability.</p></li>
</ul>
<p><strong><em>Real world Use-Cases</em></strong></p>
<p><strong>1. Cloud Architecture Visualization</strong> - Helps in designing and documenting cloud architectures across platforms like AWS, GCP, Azure, Kubernetes, Alibaba Cloud and Oracle Cloud.</p>
<ul>
<li><p>Example – Generates AWS network topology diagrams programmatically.</p></li>
<li></li>
<li><p>Benefits: Automates cloud architecture documentation, ensuring up-to-date diagrams.</p></li>
</ul>
<p><strong>2. Software System Design</strong> - Engineers and architects can expertly create flowcharts for software modules, microservices, and APIs.</p>
<ul>
<li><p>Example: Clearly representing data flow in a microservices-based application.</p></li>
<li></li>
<li><p>Benefits: Provides clear system design documentation.</p></li>
</ul>
<p><strong>3. Hybrid Cloud and Multi-Cloud Architecture</strong> - Helps architects visualize hybrid cloud (on-prem + cloud) and multi-cloud (AWS + GCP + Azure) environments.</p>
<ul>
<li><p>Example: Hybrid cloud infrastructure with AWS and on-premises resources.</p></li>
<li><p>Benefits: Helps organizations design failover and disaster recovery plans.</p></li>
</ul>
<p><strong>4. Security Architecture Visualization</strong> - Useful for compliance and security reviews (ISO, NIST, SOC2). - - Example: Security Architecture for a Web Application. - - Benefits: Helps organizations comply with security policies and audits (ISO, SOC2, NIST).</p>
<p><strong><em>References</em></strong></p>
<ol type="1">
<li><strong>mingrammer/diagrams GitHub Repository</strong></li>
</ol>
<ul>
<li><p>URL: https://github.com/mingrammer/diagrams</p></li>
<li><p>Description: Official GitHub repository with source code, examples, and documentation.</p></li>
</ul>
<ol start="2" type="1">
<li><strong>mingrammer/diagrams Documentation</strong></li>
</ol>
<ul>
<li><p>URL: https://diagrams.mingrammer.com</p></li>
<li><p>Description: Official documentation explaining installation and usage.</p></li>
</ul>
<ol start="3" type="1">
<li><strong>YouTube – Python Diagrams for DevOps and Cloud Architecture</strong></li>
</ol>
<ul>
<li>https://youtu.be/Oa-_EUg44cQ?feature=shared</li>
</ul>
<p><strong><em>Conclusion:</em></strong></p>
<ul>
<li>The mingrammer/diagrams library stands out as a powerful and versatile tool designed for users who need to create diagrams related to infrastructure, software, and networks using Python code.</li>
<li>This library offers a significant advantage over traditional diagramming tools like Microsoft Visio or Draw.io by automating the diagramming process.</li>
<li>As a result, it ensures that the system architecture remains consistent, up-to-date, and easily version-controlled, providing a streamlined approach to diagram creation.</li>
</ul>
<p><strong><em>Challenges:</em></strong></p>
<ul>
<li><p>Requires basic Python knowledge for scripting diagrams.</p></li>
<li><p>Limited styling options compared to UI-based tools.</p></li>
<li><p>Unlike Google Drawings or Miro, diagrams lacks real-time team collaboration features.</p></li>
</ul>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp("https:\/\/PriyankaR1605\.github\.io\/Exposition-Assignment-PSDV\/");
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>